<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_player_mia_stand_down</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-10</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Player Initiate
vx = 0;
vy = 0;
player_speed = 1;
player_state = "state_walk";
direction = 270;
face_dir = "down"; //used to keep track of which of the 4 directional sprites the player is uing. Need this for attacking animation

//Determines how long the player stays in the attacking state
attack_timer = 0;
attack_timer_max = 30;

player_life = 4;
player_life_max = 4;
can_take_damage = true;
hurt_timer = 0;
carry_inst = self;
carry_sprite = sprite_index;

is_flashing = false;
flashing_timer = 0;
flash_state = 1;
invincible_timer = 0;
can_climb_stairs = false;
draw_shadow = true;

finish_recipe = false;
recipe_success = false;
pot_offset = 0;
result_offset = 16;
result_alpha = 0;
close_recipe_timer = 90;
last_enemy_name = "";
last_enemy_sprite = spr_enemy;
recipe_item_1 = sprite_index;
recipe_item_2 = sprite_index;
recipe_success_name = "Test";

//death state
death_bar_left_x = 0;
death_bar_right_x = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>instance_create(0,0,obj_mini_slider);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Player Movement buttons
left = keyboard_check(vk_left);
right = keyboard_check(vk_right);
up = keyboard_check(vk_up);
down = keyboard_check(vk_down);
attack = keyboard_check_pressed(ord("Z"));
pickup = keyboard_check_pressed(ord("X"));

if((keyboard_check_pressed(vk_enter))or(keyboard_check_pressed(vk_escape))){
    if!(game_is_paused()){
        game_set_pause(true);
    }else{
        game_set_pause(false);
    };
};

if!(game_is_paused()){
    //finite state machine
    switch(player_state){
        case "state_walk":
            can_take_damage = true;
            can_climb_stairs = true;
            //set x and y velocity according to player inputs
            vx = (right - left) * player_speed;
            vy = (down - up) * player_speed;
            
            //get direction the player is holding, if the player is holding a direction. This is used for animation
            if((left)or(up)or(right)or(down)){
                direction = point_direction(0,0,right - left,down - up);
            };
            
            //Move to attacking state if Z is pressed
            if(attack){
                player_state = "state_attack";
                image_index = 0;
                attack_timer = attack_timer_max;
                vx = 0;
                vy = 0;
            };
            
            //carry items
            if((pickup)and(place_meeting(x,y,obj_drop))){
                var drop_inst = instance_nearest(x,y,obj_drop);
                
                audio_play_sound(snd_pickitem,10,0);
                player_state = "state_carry";
                carry_inst = drop_inst.object_index;
                carry_sprite = drop_inst.sprite_index;
                with(drop_inst){
                    instance_destroy();
                };
            };
            break;
            
        case "state_attack":
            can_take_damage = false;
            can_climb_stairs = false;
            if(attack_timer &gt; 0){
                //create attack object after certain frame
                //if((attack_timer &lt; attack_timer_max - 12)and!(instance_exists(obj_attack_player))){
                if!(instance_exists(obj_attack_player)){
                        instance_create(x+lengthdir_x(16,direction),y+lengthdir_y(16,direction),obj_attack_player);
                };
                attack_timer--;
            }else{
                //destroy attack object, if it exists, and then exit state
                if(instance_exists(obj_attack_player)){
                    with(obj_attack_player){
                        instance_destroy();
                    };
                };
                player_state = "state_walk";
            };
            break;
            
        case "state_hurt":
            can_take_damage = false;
            can_climb_stairs = false;
            is_flashing = true;
            view_xview = choose(-0.5,0,0.5);
            view_yview = choose(-0.5,0,0.5);
            
            if(hurt_timer &gt; 0){
                hurt_timer--;
                vx = lerp(0,vx,0.95);
                vy = lerp(0,vy,0.95);
            }else{
                player_state = "state_walk";
                view_xview = 0;
                view_yview = 0;
                //is_flashing = false;
                flash_state = 1;
                vx = 0;
                vy = 0;
            };
            break;
            
        case "state_carry":
            can_take_damage = true;
            can_climb_stairs = true;
            //set x and y velocity according to player inputs
            vx = (right - left) * player_speed;
            vy = (down - up) * player_speed;
            
            //get direction the player is holding, if the player is holding a direction. This is used for animation
            if((left)or(up)or(right)or(down)){
                direction = point_direction(0,0,right - left,down - up);
            };
            
        
            //giving food to door
            if((pickup)and(place_meeting(x,y-16,obj_door))){
                obj_door.door_state = "state_eating";
                obj_door.food_given = carry_sprite;
                player_state = "state_walk";
                carry_inst = self;
                carry_sprite = spr_cooked_mistake;
            }else if((pickup)and(place_meeting(x,y,obj_drop))){
            //cooking
                var drop_inst = instance_nearest(x,y,obj_drop);
                
                player_state = "state_recipe";
                recipe_item_1 = carry_sprite;
                recipe_item_2 = drop_inst.sprite_index;
                carry_inst = self;
                alarm[0] = room_speed/2;
                with(drop_inst){
                    instance_destroy();
                };
            }else if(pickup){
            //drop item
                player_state = "state_walk";
                audio_play_sound(snd_pickitem,10,0);
                instance_create(x,y,carry_inst);
                carry_inst = self;
            };
            break;
            
        case "state_recipe":
            game_set_pause(true);
            break;
            
        case "state_dead":
            can_climb_stairs = false;
            game_set_pause(true);
            vx = 0;
            vy = 0;
            break;
            
        case "state_climb":
            can_climb_stairs = false;
            vx = 0;
            vy = -0.06;
            break;
    };
    
    //climb exit stairs
    if((can_climb_stairs)and(place_meeting(x,y,obj_level_exit))){
        x = obj_level_exit.x;
        y = obj_level_exit.y;
        player_state = "state_climb";
        image_index = 0;
    };
    
    //taking damage
    if((can_take_damage)and(invincible_timer &gt; 0)){
        invincible_timer--;
    };
    if((is_flashing)and(invincible_timer == 0)){
        is_flashing = false;
        flash_state = 1;
    };
    if((place_meeting(x, y, obj_attack_enemy))and(can_take_damage)and(invincible_timer &lt;= 0)){
        var hurt_inst = instance_nearest(x,y,obj_attack_enemy);
        
        if(hurt_inst.can_damage_player == true){
            audio_play_sound(snd_player_hurt,10,0);
            if(carry_inst != self){
                instance_create(x,y,carry_inst);
                carry_inst = self;
                audio_play_sound(snd_pickitem,10,0);
            };
            player_state = "state_hurt";
            player_life--;
            flashing_timer = 1;
            hurt_timer = 20;
            invincible_timer = 60;
            vy = lengthdir_y(2, point_direction(hurt_inst.x, hurt_inst.y, x, y))
            vx = lengthdir_x(2, point_direction(hurt_inst.x, hurt_inst.y, x, y))
            
            //die
            if(player_life &lt;= 0){
                player_state = "state_dead";
                death_bar_left_x = round((x - room_width));
                death_bar_right_x = round((x + room_width));
            };
        };
    };
    
    //flashing
    ///flash timer
    if(is_flashing){
        if(flashing_timer &gt; 0){
            flashing_timer--;
        }else{
            if(flash_state == 1){
                flash_state = 0;
            }else{
                flash_state = 1;
            };
            flashing_timer = 8;
        }
    };
    
    //physics
    if!(place_meeting(x + vx, y, obj_solid)){
        x += vx;
    };
    if!(place_meeting(x, y + vy, obj_solid)){
        y += vy;
    };
};
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="7">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(player_state == "state_climb"){
    player_state  = "state_walk";
    player_life = player_life_max;
    room = obj_level_exit.warp_room;
};
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>x = obj_player_spawn.x;
y = obj_player_spawn.y;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//draw last enemy defeated
draw_sprite(last_enemy_sprite,0,4,view_hview-4);
draw_text(20,view_hview-14,last_enemy_name);

//draw hud portrait
draw_sprite(spr_hud_portrait,(player_state == "state_hurt"),8,8);

//draw lifebar
for(a = 0;a &lt; player_life_max;a++){
    draw_sprite(spr_hud_lifefruit,1, 40+(a*16),16);
};
player_life = clamp(player_life,0,player_life_max);

for(a = 0;a &lt; player_life;a++){
    draw_sprite(spr_hud_lifefruit,0, 40+(a*16),16)
};    

//draw the recipe minigame screen
if(player_state == "state_recipe"){
    draw_set_color(c_black);
    draw_set_alpha(0.75);
    draw_rectangle(0,0,view_wview,view_hview,0);
    draw_set_alpha(1);
    draw_set_color(c_white);
    draw_set_halign(fa_center);
    draw_text(view_wview/2,64,"Press X to cook at# the right time!")
    draw_set_halign(fa_left);
    
    //only move the pan and draw results after you've finished the minigame
    if(finish_recipe == true){
        if(pot_offset &gt; -16){
            pot_offset--;
        };
        if(result_offset &gt; 0){
            result_offset--;
        };
        if(result_alpha &lt; 1){
            result_alpha += 0.1;
        };
        
        draw_set_alpha(result_alpha);
        draw_sprite(spr_hud_result,recipe_success,(view_wview/2)+32,(view_hview/2)+16+result_offset);
        draw_set_alpha(1);
        
        //draw recipe results
        if(recipe_success){
            scr_get_recipe_result(recipe_item_1,recipe_item_2);
                
            draw_sprite(carry_sprite,0,(view_wview/2)-12,(view_hview/2)+6);
            draw_text((view_wview/2),(view_hview/2)-2,recipe_success_name);
        }else{
            scr_get_recipe_result(spr_cooked_mistake,spr_cooked_mistake);
                
            draw_sprite(carry_sprite,0,(view_wview/2)-12,(view_hview/2)+6);
            draw_text((view_wview/2),(view_hview/2)-2,recipe_success_name);
        };
        
        //close the recipe minigame after another second has passed
        if(close_recipe_timer &gt; 0){
            close_recipe_timer--;
        }else{
            if(recipe_success){
                player_state = "state_carry";
            }else{
                player_state = "state_walk";
            };
            game_set_pause(false);
            finish_recipe = false;
            recipe_success = false;
            pot_offset = 0;
            result_offset = 16;
            result_alpha = 0;
            close_recipe_timer = 90;
        };
    };
    draw_sprite(spr_hud_pot,0,(view_wview/2)+pot_offset,(view_hview/2)+16);
    draw_sprite(spr_hud_minigame,0,view_wview/2,(view_hview/2)+40);  

//draw gui when player is dead
}else if(player_state == "state_dead"){
    draw_set_color(c_black);
    draw_rectangle(-room_width,0,death_bar_left_x,room_height,0);
    draw_rectangle(death_bar_right_x,0,room_width*2,room_height,0);
    
    draw_set_color(c_white);
    draw_sprite_ext(sprite_index,image_index,round(x),round(y),image_xscale,image_yscale,image_angle,image_blend,1);
    
    //Black bars come in from the sides
    if!(death_bar_left_x &gt; death_bar_right_x){
        death_bar_left_x += 2;
        death_bar_right_x -= 2;
        
        //RIGHT
        if(face_dir == "right"){
            sprite_index = spr_player_mia_hurt_right;
            direction = 0;
        //UP
        }else if(face_dir == "up"){
            sprite_index = spr_player_mia_hurt_up;
            direction = 90;
        //LEFT
        }else if(face_dir == "left"){
            sprite_index = spr_player_mia_hurt_left;
            direction = 180;
        //DOWN
        }else if(face_dir == "down"){
            sprite_index = spr_player_mia_hurt_down;
            direction = 270;
        };
    //player spins and falls down
    }else if(sprite_index != spr_player_mia_die_2){
        sprite_index = spr_player_mia_die;
        if(image_index &lt; 15){
            image_index += 0.15;
        }else{
            sprite_index = spr_player_mia_die_2;
            background_visible[1] = true;
            background_alpha[1] = 0;
        };
    //game over appears with menu
    }else{
        if(background_alpha[1] &lt; 1){
            background_alpha[1] += 0.01;       
        };
        draw_background_ext(bg_gameover,background_x[1],background_y[1],1,1,0,c_white,background_alpha[1]);
        
    };
};
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if!(game_is_paused()){
    //finite state machine
    switch(player_state){
        case "state_walk":
            draw_shadow = true;
            //sprites to use when moving
            if((left)or(up)or(right)or(down)){
                image_speed = 0.125;
                //RIGHT
                if(direction == 0){
                    sprite_index = spr_player_mia_walk_right;face_dir = "right";
                //UP
                }else if(direction == 90){
                    sprite_index = spr_player_mia_walk_up;face_dir = "up";
                //LEFT
                }else if(direction == 180){
                    sprite_index = spr_player_mia_walk_left;face_dir = "left";
                //DOWN
                }else if(direction == 270){
                    sprite_index = spr_player_mia_walk_down;face_dir = "down";
                }else{
                //MOVING IN A DIAGONAL DIRECTION
                //This is to fix the walking backwards bug
                    //RIGHT
                    if((face_dir == "right")and(abs(angle_difference(0,direction)) &gt;= 135)){
                        sprite_index = spr_player_mia_walk_left;face_dir = "left";
                    //UP
                    }else if((face_dir == "up")and(abs(angle_difference(90,direction)) &gt;= 135)){
                        sprite_index = spr_player_mia_walk_down;face_dir = "down";
                    //LEFT
                    }else if((face_dir == "left")and(abs(angle_difference(180,direction)) &gt;= 135)){
                        sprite_index = spr_player_mia_walk_right;face_dir = "right";
                    //DOWN
                    }else if((face_dir == "down")and(abs(angle_difference(270,direction)) &gt;= 135)){
                        sprite_index = spr_player_mia_walk_up;face_dir = "up";
                    };
                };
            //sprites to use while standing still
            }else{
                image_speed = 0;
                //RIGHT
                if(face_dir == "right"){
                    sprite_index = spr_player_mia_stand_right;direction = 0;
                //UP
                }else if(face_dir == "up"){
                    sprite_index = spr_player_mia_stand_up;direction = 90;
                //LEFT
                }else if(face_dir == "left"){
                    sprite_index = spr_player_mia_stand_left;direction = 180;
                //DOWN
                }else if(face_dir == "down"){
                    sprite_index = spr_player_mia_stand_down;direction = 270;
                };
            };
            break;
            
        case "state_attack":
            draw_shadow = true;
            //stop the animation before it loops
            if(image_index &lt; image_number){
                image_speed = 0.15;
            }else{
                image_speed = 0;
            };

            //RIGHT
            if(face_dir == "right"){
                sprite_index = spr_player_mia_attack_right;
                direction = 0;
            //UP
            }else if(face_dir == "up"){
                sprite_index = spr_player_mia_attack_up;
                direction = 90;
            //LEFT
            }else if(face_dir == "left"){
                sprite_index = spr_player_mia_attack_left;
                direction = 180;
            //DOWN
            }else if(face_dir == "down"){
                sprite_index = spr_player_mia_attack_down;
                direction = 270;
            };
            break;
            
     case "state_hurt":
     case "state_dead":
           draw_shadow = true;
           //RIGHT
            if(face_dir == "right"){
                sprite_index = spr_player_mia_hurt_right;
                direction = 0;
            //UP
            }else if(face_dir == "up"){
                sprite_index = spr_player_mia_hurt_up;
                direction = 90;
            //LEFT
            }else if(face_dir == "left"){
                sprite_index = spr_player_mia_hurt_left;
                direction = 180;
            //DOWN
            }else if(face_dir == "down"){
                sprite_index = spr_player_mia_hurt_down;
                direction = 270;
            };
            break;
            
    case "state_carry":
            draw_shadow = true;
            //sprites to use when moving
            if((left)or(up)or(right)or(down)){
                image_speed = 0.15;
                //RIGHT
                if(direction == 0){
                    sprite_index = spr_player_mia_walk_right;face_dir = "right";
                //UP
                }else if(direction == 90){
                    sprite_index = spr_player_mia_walk_up;face_dir = "up";
                //LEFT
                }else if(direction == 180){
                    sprite_index = spr_player_mia_walk_left;face_dir = "left";
                //DOWN
                }else if(direction == 270){
                    sprite_index = spr_player_mia_walk_down;face_dir = "down";
                };
            //sprites to use while standing still
            }else{
                image_speed = 0;
                //RIGHT
                if(face_dir == "right"){
                    sprite_index = spr_player_mia_stand_right;direction = 0;
                //UP
                }else if(face_dir == "up"){
                    sprite_index = spr_player_mia_stand_up;direction = 90;
                //LEFT
                }else if(face_dir == "left"){
                    sprite_index = spr_player_mia_stand_left;direction = 180;
                //DOWN
                }else if(face_dir == "down"){
                    sprite_index = spr_player_mia_stand_down;direction = 270;
                };
            };
            break;
            
        case "state_climb":
            draw_shadow = false;
            sprite_index = spr_player_mia_climb;
            image_speed = 0.075;
            break;
    };
}else{
    image_speed = 0;
};

//draw player sprite
if(draw_shadow){
    draw_sprite(spr_shadow,1,round(x),round(y)+2);
};
draw_sprite_ext(sprite_index,image_index,round(x),round(y),image_xscale,image_yscale,image_angle,image_blend,1);
if(flash_state == 0){
    draw_sprite_ext(sprite_index,image_index,round(x),round(y),image_xscale,image_yscale,image_angle,make_colour_hsv(18,255,255),0.85);
};
//draw_sprite_ext(sprite_index,image_index,round(x),round(y),image_xscale,image_yscale,image_angle,image_blend,flash_state);
depth = -y;

if(player_state == "state_carry"){
    draw_sprite(carry_sprite,0,x,y-12);
};

//draw interact for pickups
if(place_meeting(x,y,obj_drop)){
    var drop_inst = instance_nearest(x,y,obj_drop);
    
    draw_sprite(spr_interact,0,drop_inst.x-8,drop_inst.y-32);
    draw_text(drop_inst.x+8,drop_inst.y-30,drop_inst.item_name);
};
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
